

#include <Arduino.h>
#include <stdio.h>
//#include <memory>

#include "DisplayRow.h"
#include "Pin.h"
//#include "SagarDisplayControlFileReader.h"
#include "DisplayOutputPinFactory.h"
#include "Script.h"
#include "SagarDisplayScriptDirector.h"
//#include "SDSReader.h"
#include "SdffParser.h"
#include "FileStream.h"

// Include data file generated by webtool that defines the pixel states
#include "PIXELS.h"


#include "SagarDisplay.h"

#define WIDTH 6
#define PIN_COUNT (2*WIDTH)

#if defined(NARDUINO)
	#define ADOP_HIGH 1
	#define ADOP_LOW 0
#else
	#define ADOP_HIGH HIGH
	#define ADOP_LOW LOW
#endif

unsigned char pixels[] = PIXELS;

SDCReader *data = NULL;
typedef DisplayOutputPin *DisplayOutputPinPtr;

DisplayOutputPinPtr *SagarDisplay::pixelPins;

/*
class DisplayScriptState: public ScriptState {
  public:
    DisplayScriptState()
      :isUpdated(false)
    {
      
    }
    ~DisplayScriptState(){}
    
    boolean isUpdated;
    
  protected:
    void onUpdate(ScriptState *state){
      isUpdated = true;
//      printf("Script state updated %i\n", state->scrollOffset);
    }
};
*/

SagarDisplayScriptDirector *director = NULL;



bool SagarDisplay::displayOK = false;
int SagarDisplay::row;
Pin *SagarDisplay::clockPin;

const unsigned long SagarDisplay::clockDurationHighMicros =  100UL;
const unsigned long SagarDisplay::clockDurationLowMicros  = 1900UL;
const int SagarDisplay::resetDurationMillis = 2500;

unsigned long nextTransitionTime;
unsigned long lastTransitionTime;
Pin::State clockState;

bool tweaked;
unsigned long tweakTime;


Script *script = NULL;

class ParserHandler: public sdff::ParseHandler {
      void parsedBox(sdff::Box *box){
        const char *boxType = box->getType();
        bool handled = false;

        //printf("Handler called for box: %s\n", boxType);

        if (0 == strcmp("disp", boxType)){
              sdff::SagarDisplayBox *dispBox = (sdff::SagarDisplayBox *)box;
              int count = dispBox->getWidth();
              unsigned long int *columns = new unsigned long[dispBox->getWidth()];
              for (int idx=0; idx != count; ++idx){
                    columns[idx] = *dispBox->getColumn(idx);
              }
              
              data = new SDCReader(dispBox->getWidth(), dispBox->getHeight(), 4*dispBox->getWidth(), columns);
              handled = true;
          }
          else if (0 == strcmp("scpt", boxType)){
              if (NULL != script){
                  printf("Already have a script box\n");
              }
              else {
                  sdff::ScriptBox *scptBox = (sdff::ScriptBox *)box;
                  script = new Script(scptBox->getFlags());   
                  handled = true;
              }
          }
          else if (0 == strcmp("sscr", boxType)){
              if (NULL == script){
                  printf("Need a script box before a script action box\n");
              }
              else {
                  sdff::ScrollScriptActionBox *sscrBox = (sdff::ScrollScriptActionBox *)box;
                  ScrollScriptAction *action = new ScrollScriptAction(
                      script,
                      sscrBox->getStep(),
                      sscrBox->getDelay(),
                      sscrBox->getCount());
                      
                  script->addScriptAction(action);

                  handled = true;
              }
          }
          else if (0 == strcmp("spos", boxType)){
              if (NULL == script){
                  printf("Need a script box before a script action box\n");
              }
              else {
                  sdff::PositionScriptActionBox *sposBox = (sdff::PositionScriptActionBox *)box;
                  PositionScriptAction *action = new PositionScriptAction(
                      script,
                      sposBox->getPosition());
                      
                  script->addScriptAction(action);
                  
                  handled = true;
              }
          }
          else if (0 == strcmp("spau", boxType)){
              if (NULL == script){
                  printf("Need a script box before a script action box\n");
              }
              else {
                  sdff::PauseScriptActionBox *spauBox = (sdff::PauseScriptActionBox *)box;
                  PauseScriptAction *action = new PauseScriptAction(
                      script,
                      spauBox->getDuration());
                      
                  script->addScriptAction(action);
                  
                  handled = true;
              }
          }
          
          if (handled){
              //printf("Event was handled\n");
          }
      }
  
};


/**
 Helper class/factory to allow a stream to be returned for either a bytearray or filename
*/
class StreamFactory {
    public:
        static sdff::Stream *get(unsigned int byteSize, unsigned char *bytes){
            return new sdff::ByteStream(sizeof(pixels), pixels);
        }
        static sdff::Stream *get(char *filename){
            return new sdff::FileStream(filename);
        }
    private:
        StreamFactory(){}
  
};


bool SagarDisplay::load(sdff::Stream *stream){
        if (NULL != data) delete data;
        if (NULL != director) delete director;
        if (NULL != script) delete script;
        
        data = NULL;
        director = NULL;
        script = NULL;

        sdff::SdffParser fileParser = sdff::SdffParser();
        ParserHandler handler;
        fileParser.setHandler(&handler);

        fileParser.parse(stream);
        
        if (NULL != script){
            script->resetScript();
            ScriptAction *actions[1] = {NULL};
            director = new SagarDisplayScriptDirector(script, actions);
            director->setDisplayWidth(WIDTH);
            director->setContentWidth(data->getWidth());
            director->setPixelData(data);
            script->setScriptState(director);
        }
        
        // TODO Figure out if I ever need to return false!
        return true;
}

bool SagarDisplay::loadFromFile(char *filename){
    sdff::Stream *stream =  StreamFactory::get(filename);
    load(stream);
  
    delete stream;
}

bool SagarDisplay::setup(){
        
        sdff::Stream *stream =  StreamFactory::get(sizeof(pixels), pixels);
        load(stream);
        delete stream;
        
        /*
	data = SDCReader::loadBytes(pixels);

	if (NULL == data) return false;

	if (data->getWidth() < WIDTH) {
		// error
		return false;
	}

	director = SDSFileReader::readScript(/*todo* /);
        */
        


	pixelPins = new DisplayOutputPinPtr[PIN_COUNT];
	int idx=0;

	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(0), 0x01, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 11);
	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(0), 0x02, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 10);

	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(1), 0x01, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 9);
	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(1), 0x02, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 8);

	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(2), 0x01, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 7);
	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(2), 0x02, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 6);

	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(3), 0x01, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 5);
	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(3), 0x02, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 4);

	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(4), 0x01, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 3);
	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(4), 0x02, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 2);

	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(5), 0x01, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 1);
	pixelPins[idx++] = DisplayOutputPinFactory::getInstance(data->get(5), 0x02, 2, data->getHeight(), ADOP_LOW, ADOP_HIGH, 0);

	row = 0;


	for (
		int it = 0;
		PIN_COUNT != it;
		++it)
	{
		(pixelPins[it])->set(Pin::low);
	}

	clockPin = Pin::get(12);
	clockPin->setup(Pin::output);

        // Clock needs a 1second high pulse to trigger a reset
	clockState = Pin::high;
	clockPin->digitalWrite(clockState);
	delay(SagarDisplay::resetDurationMillis);
        // Clock needs a short delay to recover from the reset
	clockPin->digitalWrite(Pin::low);
	delay(100);


	lastTransitionTime = micros();
	nextTransitionTime = lastTransitionTime + SagarDisplay::clockDurationHighMicros;

	displayOK = true;
	return displayOK;
}

void SagarDisplay::loop(){
	if (!displayOK) return;
	unsigned long now = micros();

	director->loop();
            
	if (director->isStateUpdated()) {
            for (int col = 0; WIDTH != col; ++col){
			unsigned long int const *coldata = director->getPixelDataForColumn(col);
            
			pixelPins[2*col]->setDataWord(coldata);
			pixelPins[2*col+1]->setDataWord(coldata);
            }
        }



	bool transition = false;
	if (nextTransitionTime >= lastTransitionTime) {
		if ( (now > nextTransitionTime) || (now < lastTransitionTime) ) {
			transition = true;
		}
	}
	else {
		if ( (now < lastTransitionTime) && (now >= nextTransitionTime) ) {
			transition = true;
		}
	}

	if (!transition) {
		// Only change display data when there's no transition
		// TODO: ensure we're not mid-cycle too.
		if (director->isStateUpdated()) {
			for (int col = 0; WIDTH != col; ++col){
				unsigned long int const *coldata = director->getPixelDataForColumn(col);

				pixelPins[2*col]->setDataWord(coldata);
				pixelPins[2*col+1]->setDataWord(coldata);
			}
		}

		return;
	}

	if (Pin::low == clockState) {
		for (
			int it = 0;
			PIN_COUNT != it;
			++it)
		{
			(pixelPins[it])->set(Pin::low);
		}

		clockState = Pin::high;
		clockPin->digitalWrite(clockState);
		lastTransitionTime = now;
		nextTransitionTime = now + SagarDisplay::clockDurationHighMicros;

		++row;
		int reset = 0;
		if (data->getHeight() == row){
			row = 0;
			reset = 1;
		}

		for (
			int it = 0;
			PIN_COUNT != it;
			++it)
		{
			if (reset){
				(pixelPins[it])->resetPosition();
			}
			else {
				(pixelPins[it])->incPosition();
			}
		}

	}
	else {
		clockState = Pin::low;
		clockPin->digitalWrite(clockState);
		lastTransitionTime = now;
		nextTransitionTime = now + SagarDisplay::clockDurationLowMicros;

                for (
                    int it = 0;
                    PIN_COUNT != it;
                    ++it)
                {
                    (pixelPins[it])->evaluate();
                }
	}
}
